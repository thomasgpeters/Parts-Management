const cron = require('node-cron');
const prisma = require('../db');

// Check inventory levels and create reorder alerts
async function checkAndCreateReorderAlerts() {
  console.log('Running auto-reorder check...');

  const inventory = await prisma.inventory.findMany({
    include: {
      part: {
        include: { vendor: true }
      }
    }
  });

  const newAlerts = [];

  for (const item of inventory) {
    // Skip inactive parts or parts without vendor
    if (!item.part?.isActive) continue;

    // Check if below reorder point
    if (item.quantityOnHand <= item.reorderPoint) {
      // Check if there's already a pending alert for this part
      const existingAlert = await prisma.reorderAlert.findFirst({
        where: {
          partId: item.partId,
          status: 'PENDING'
        }
      });

      if (!existingAlert) {
        const alert = await prisma.reorderAlert.create({
          data: {
            partId: item.partId,
            partNumber: item.part.partNumber,
            partName: item.part.name,
            currentQty: item.quantityOnHand,
            reorderPoint: item.reorderPoint,
            reorderQty: item.reorderQuantity,
            vendorId: item.part.vendorId,
            vendorName: item.part.vendor?.name
          }
        });
        newAlerts.push(alert);
        console.log(`Created reorder alert for ${item.part.partNumber}`);
      }
    }
  }

  console.log(`Auto-reorder check complete. Created ${newAlerts.length} new alerts.`);
  return newAlerts;
}

// Process a single reorder alert - create an order
async function processReorderAlert(alertId) {
  const alert = await prisma.reorderAlert.findUnique({
    where: { id: alertId }
  });

  if (!alert) {
    return { success: false, error: 'Alert not found' };
  }

  if (alert.status !== 'PENDING') {
    return { success: false, error: 'Alert is not pending' };
  }

  if (!alert.vendorId) {
    return { success: false, error: 'No vendor assigned to this part' };
  }

  // Get part details
  const part = await prisma.part.findUnique({
    where: { id: alert.partId }
  });

  if (!part) {
    return { success: false, error: 'Part not found' };
  }

  // Generate order number
  const date = new Date();
  const prefix = `PO${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, '0')}`;
  const lastOrder = await prisma.order.findFirst({
    where: { orderNumber: { startsWith: prefix } },
    orderBy: { orderNumber: 'desc' }
  });

  let sequence = 1;
  if (lastOrder) {
    sequence = parseInt(lastOrder.orderNumber.slice(-4)) + 1;
  }
  const orderNumber = `${prefix}${String(sequence).padStart(4, '0')}`;

  const totalPrice = alert.reorderQty * part.unitPrice;

  // Create order
  const order = await prisma.order.create({
    data: {
      orderNumber,
      vendorId: alert.vendorId,
      status: 'PENDING',
      isAutoGenerated: true,
      subtotal: totalPrice,
      total: totalPrice,
      notes: `Auto-generated from reorder alert #${alertId}`,
      items: {
        create: {
          partId: alert.partId,
          quantity: alert.reorderQty,
          unitPrice: part.unitPrice,
          totalPrice
        }
      }
    },
    include: {
      vendor: true,
      items: { include: { part: true } }
    }
  });

  // Update alert status
  await prisma.reorderAlert.update({
    where: { id: alertId },
    data: {
      status: 'ORDERED',
      orderId: order.id,
      processedAt: new Date()
    }
  });

  console.log(`Processed reorder alert #${alertId}, created order ${orderNumber}`);

  return { success: true, order };
}

// Initialize the auto-reorder scheduler
function initializeAutoReorder() {
  const cronSchedule = process.env.AUTO_REORDER_CRON || '0 */6 * * *'; // Default: every 6 hours

  cron.schedule(cronSchedule, async () => {
    try {
      await checkAndCreateReorderAlerts();
    } catch (error) {
      console.error('Auto-reorder check failed:', error);
    }
  });

  console.log(`Auto-reorder scheduler started with schedule: ${cronSchedule}`);

  // Run initial check on startup
  setTimeout(async () => {
    try {
      await checkAndCreateReorderAlerts();
    } catch (error) {
      console.error('Initial auto-reorder check failed:', error);
    }
  }, 5000);
}

module.exports = {
  checkAndCreateReorderAlerts,
  processReorderAlert,
  initializeAutoReorder
};
