const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');
const prisma = require('../db');

// Generate unique order number
const generateOrderNumber = async () => {
  const date = new Date();
  const prefix = `PO${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, '0')}`;

  const lastOrder = await prisma.order.findFirst({
    where: { orderNumber: { startsWith: prefix } },
    orderBy: { orderNumber: 'desc' }
  });

  let sequence = 1;
  if (lastOrder) {
    const lastSequence = parseInt(lastOrder.orderNumber.slice(-4));
    sequence = lastSequence + 1;
  }

  return `${prefix}${String(sequence).padStart(4, '0')}`;
};

// Calculate order totals
const calculateOrderTotals = (items, tax = 0, shipping = 0) => {
  const subtotal = items.reduce((sum, item) => sum + item.totalPrice, 0);
  return {
    subtotal: Math.round(subtotal * 100) / 100,
    tax: Math.round(tax * 100) / 100,
    shipping: Math.round(shipping * 100) / 100,
    total: Math.round((subtotal + tax + shipping) * 100) / 100
  };
};

// GET /api/orders - List all orders
router.get('/', async (req, res, next) => {
  try {
    const {
      status,
      vendorId,
      startDate,
      endDate,
      isAutoGenerated,
      sortBy = 'createdAt',
      order = 'desc',
      page = 1,
      limit = 50
    } = req.query;

    const where = {};
    if (status) where.status = status;
    if (vendorId) where.vendorId = parseInt(vendorId);
    if (isAutoGenerated !== undefined) where.isAutoGenerated = isAutoGenerated === 'true';
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }

    const orders = await prisma.order.findMany({
      where,
      include: {
        vendor: true,
        items: {
          include: { part: true }
        },
        _count: { select: { items: true } }
      },
      orderBy: { [sortBy]: order },
      skip: (parseInt(page) - 1) * parseInt(limit),
      take: parseInt(limit)
    });

    const total = await prisma.order.count({ where });

    res.json({
      data: orders,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    next(error);
  }
});

// GET /api/orders/summary - Get orders summary
router.get('/summary', async (req, res, next) => {
  try {
    const orders = await prisma.order.findMany();

    const summary = {
      total: orders.length,
      byStatus: {},
      totalValue: 0,
      thisMonth: 0,
      thisMonthValue: 0
    };

    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

    orders.forEach(order => {
      summary.byStatus[order.status] = (summary.byStatus[order.status] || 0) + 1;
      summary.totalValue += order.total;

      if (order.createdAt >= startOfMonth) {
        summary.thisMonth++;
        summary.thisMonthValue += order.total;
      }
    });

    summary.totalValue = Math.round(summary.totalValue * 100) / 100;
    summary.thisMonthValue = Math.round(summary.thisMonthValue * 100) / 100;

    res.json(summary);
  } catch (error) {
    next(error);
  }
});

// GET /api/orders/:id - Get order by ID
router.get('/:id', async (req, res, next) => {
  try {
    const order = await prisma.order.findUnique({
      where: { id: parseInt(req.params.id) },
      include: {
        vendor: true,
        items: {
          include: {
            part: {
              include: { inventory: true }
            }
          }
        },
        inventoryLogs: true
      }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    res.json(order);
  } catch (error) {
    next(error);
  }
});

// POST /api/orders - Create new order
router.post('/', [
  body('vendorId').isInt().withMessage('Vendor ID is required'),
  body('items').isArray({ min: 1 }).withMessage('At least one item is required'),
  body('items.*.partId').isInt().withMessage('Part ID is required'),
  body('items.*.quantity').isInt({ min: 1 }).withMessage('Quantity must be at least 1'),
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { vendorId, items, notes, shippingAddress, tax = 0, shipping = 0, isAutoGenerated = false } = req.body;

    // Verify vendor exists
    const vendor = await prisma.vendor.findUnique({ where: { id: vendorId } });
    if (!vendor) {
      return res.status(400).json({ error: 'Vendor not found' });
    }

    // Get part prices and prepare items
    const orderItems = await Promise.all(items.map(async (item) => {
      const part = await prisma.part.findUnique({ where: { id: item.partId } });
      if (!part) {
        throw new Error(`Part with ID ${item.partId} not found`);
      }
      const unitPrice = item.unitPrice || part.unitPrice;
      return {
        partId: item.partId,
        quantity: item.quantity,
        unitPrice,
        totalPrice: unitPrice * item.quantity,
        notes: item.notes
      };
    }));

    const totals = calculateOrderTotals(orderItems, tax, shipping);
    const orderNumber = await generateOrderNumber();

    const order = await prisma.order.create({
      data: {
        orderNumber,
        vendorId,
        status: 'DRAFT',
        notes,
        shippingAddress,
        isAutoGenerated,
        ...totals,
        items: {
          create: orderItems
        }
      },
      include: {
        vendor: true,
        items: {
          include: { part: true }
        }
      }
    });

    res.status(201).json(order);
  } catch (error) {
    next(error);
  }
});

// PUT /api/orders/:id - Update order
router.put('/:id', async (req, res, next) => {
  try {
    const orderId = parseInt(req.params.id);
    const { notes, shippingAddress, tax, shipping, expectedDate } = req.body;

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { items: true }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    if (!['DRAFT', 'PENDING'].includes(order.status)) {
      return res.status(400).json({ error: 'Cannot modify order in current status' });
    }

    const totals = calculateOrderTotals(order.items, tax ?? order.tax, shipping ?? order.shipping);

    const updated = await prisma.order.update({
      where: { id: orderId },
      data: {
        notes,
        shippingAddress,
        expectedDate: expectedDate ? new Date(expectedDate) : undefined,
        ...totals
      },
      include: {
        vendor: true,
        items: { include: { part: true } }
      }
    });

    res.json(updated);
  } catch (error) {
    next(error);
  }
});

// POST /api/orders/:id/items - Add item to order
router.post('/:id/items', [
  body('partId').isInt().withMessage('Part ID is required'),
  body('quantity').isInt({ min: 1 }).withMessage('Quantity must be at least 1'),
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const orderId = parseInt(req.params.id);
    const { partId, quantity, unitPrice: customPrice, notes } = req.body;

    const order = await prisma.order.findUnique({ where: { id: orderId } });
    if (!order || !['DRAFT', 'PENDING'].includes(order.status)) {
      return res.status(400).json({ error: 'Cannot add items to this order' });
    }

    const part = await prisma.part.findUnique({ where: { id: partId } });
    if (!part) {
      return res.status(400).json({ error: 'Part not found' });
    }

    const unitPrice = customPrice || part.unitPrice;
    const totalPrice = unitPrice * quantity;

    await prisma.orderItem.create({
      data: {
        orderId,
        partId,
        quantity,
        unitPrice,
        totalPrice,
        notes
      }
    });

    // Recalculate order totals
    const items = await prisma.orderItem.findMany({ where: { orderId } });
    const totals = calculateOrderTotals(items, order.tax, order.shipping);

    const updated = await prisma.order.update({
      where: { id: orderId },
      data: totals,
      include: {
        vendor: true,
        items: { include: { part: true } }
      }
    });

    res.json(updated);
  } catch (error) {
    next(error);
  }
});

// DELETE /api/orders/:id/items/:itemId - Remove item from order
router.delete('/:id/items/:itemId', async (req, res, next) => {
  try {
    const orderId = parseInt(req.params.id);
    const itemId = parseInt(req.params.itemId);

    const order = await prisma.order.findUnique({ where: { id: orderId } });
    if (!order || !['DRAFT', 'PENDING'].includes(order.status)) {
      return res.status(400).json({ error: 'Cannot modify this order' });
    }

    await prisma.orderItem.delete({ where: { id: itemId } });

    // Recalculate totals
    const items = await prisma.orderItem.findMany({ where: { orderId } });
    const totals = calculateOrderTotals(items, order.tax, order.shipping);

    const updated = await prisma.order.update({
      where: { id: orderId },
      data: totals,
      include: {
        vendor: true,
        items: { include: { part: true } }
      }
    });

    res.json(updated);
  } catch (error) {
    next(error);
  }
});

// PATCH /api/orders/:id/status - Update order status
router.patch('/:id/status', [
  body('status').isIn(['DRAFT', 'PENDING', 'APPROVED', 'ORDERED', 'SHIPPED', 'RECEIVED', 'CANCELLED'])
    .withMessage('Invalid status'),
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const orderId = parseInt(req.params.id);
    const { status, trackingNumber } = req.body;

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { items: true }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    // Status transition validation
    const validTransitions = {
      DRAFT: ['PENDING', 'CANCELLED'],
      PENDING: ['APPROVED', 'CANCELLED'],
      APPROVED: ['ORDERED', 'CANCELLED'],
      ORDERED: ['SHIPPED', 'CANCELLED'],
      SHIPPED: ['RECEIVED'],
      RECEIVED: [],
      CANCELLED: []
    };

    if (!validTransitions[order.status].includes(status)) {
      return res.status(400).json({
        error: `Cannot transition from ${order.status} to ${status}`
      });
    }

    const updateData = { status };

    if (status === 'ORDERED') {
      updateData.orderDate = new Date();
    }

    if (status === 'SHIPPED' && trackingNumber) {
      updateData.trackingNumber = trackingNumber;
    }

    if (status === 'RECEIVED') {
      updateData.receivedDate = new Date();

      // Update inventory for all items
      for (const item of order.items) {
        const inventory = await prisma.inventory.findUnique({
          where: { partId: item.partId }
        });

        if (inventory) {
          const previousQty = inventory.quantityOnHand;
          const newQty = previousQty + item.quantity;

          await prisma.$transaction([
            prisma.inventory.update({
              where: { partId: item.partId },
              data: {
                quantityOnHand: newQty,
                lastOrderDate: new Date()
              }
            }),
            prisma.inventoryLog.create({
              data: {
                partId: item.partId,
                changeType: 'RECEIVE',
                quantityChange: item.quantity,
                previousQty,
                newQty,
                orderId,
                reason: `Received from order ${order.orderNumber}`
              }
            }),
            prisma.orderItem.update({
              where: { id: item.id },
              data: { quantityReceived: item.quantity }
            })
          ]);
        }
      }
    }

    const updated = await prisma.order.update({
      where: { id: orderId },
      data: updateData,
      include: {
        vendor: true,
        items: { include: { part: true } }
      }
    });

    res.json(updated);
  } catch (error) {
    next(error);
  }
});

// POST /api/orders/:id/receive-partial - Partially receive order
router.post('/:id/receive-partial', [
  body('items').isArray().withMessage('Items array is required'),
  body('items.*.itemId').isInt().withMessage('Item ID is required'),
  body('items.*.quantity').isInt({ min: 1 }).withMessage('Quantity must be at least 1'),
], async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const orderId = parseInt(req.params.id);
    const { items } = req.body;

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { items: true }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    if (!['ORDERED', 'SHIPPED'].includes(order.status)) {
      return res.status(400).json({ error: 'Order must be in ORDERED or SHIPPED status' });
    }

    for (const receiveItem of items) {
      const orderItem = order.items.find(i => i.id === receiveItem.itemId);
      if (!orderItem) continue;

      const remainingQty = orderItem.quantity - orderItem.quantityReceived;
      const qtyToReceive = Math.min(receiveItem.quantity, remainingQty);

      if (qtyToReceive <= 0) continue;

      const inventory = await prisma.inventory.findUnique({
        where: { partId: orderItem.partId }
      });

      if (inventory) {
        const previousQty = inventory.quantityOnHand;
        const newQty = previousQty + qtyToReceive;

        await prisma.$transaction([
          prisma.inventory.update({
            where: { partId: orderItem.partId },
            data: {
              quantityOnHand: newQty,
              lastOrderDate: new Date()
            }
          }),
          prisma.inventoryLog.create({
            data: {
              partId: orderItem.partId,
              changeType: 'RECEIVE',
              quantityChange: qtyToReceive,
              previousQty,
              newQty,
              orderId,
              reason: `Partial receipt from order ${order.orderNumber}`
            }
          }),
          prisma.orderItem.update({
            where: { id: orderItem.id },
            data: {
              quantityReceived: orderItem.quantityReceived + qtyToReceive
            }
          })
        ]);
      }
    }

    // Check if all items are fully received
    const updatedOrder = await prisma.order.findUnique({
      where: { id: orderId },
      include: { items: true }
    });

    const allReceived = updatedOrder.items.every(i => i.quantityReceived >= i.quantity);

    if (allReceived) {
      await prisma.order.update({
        where: { id: orderId },
        data: {
          status: 'RECEIVED',
          receivedDate: new Date()
        }
      });
    }

    const finalOrder = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        vendor: true,
        items: { include: { part: true } }
      }
    });

    res.json(finalOrder);
  } catch (error) {
    next(error);
  }
});

// DELETE /api/orders/:id - Delete order (only drafts)
router.delete('/:id', async (req, res, next) => {
  try {
    const order = await prisma.order.findUnique({
      where: { id: parseInt(req.params.id) }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    if (order.status !== 'DRAFT') {
      return res.status(400).json({ error: 'Can only delete draft orders' });
    }

    await prisma.order.delete({
      where: { id: parseInt(req.params.id) }
    });

    res.json({ message: 'Order deleted successfully' });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
